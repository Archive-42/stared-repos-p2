# Groupping & Aggregates

Not all users must deal with the data as it is stored in the database, as data is generally stored at the lowest level of granularity needed.

Data can be grouped and aggregated to allow users to interact with it at some higher level of granularity that what is stored in the database.

## Grouping Concepts

Group data by a distinct value in the `open_emp_id` column:
```sql
SELECT open_emp_id
FROM account
GROUP BY open_emp_id;
```

Too see how many accounts each teller opened, you can use an _aggregate_ function in the `select` clause to count the number of orws in each group:
```sql
SELECT open_emp_id, COUNT(*) how_many
FROM account
GROUP BY open_emp_id;
```

You can filter with a `having` clause:
```sql
SELECT open_emp_id, COUNT(*) how_many
FROM account
GROUP BY open_emp_id
HAVING COUNT(*) > 4;
```

## Aggregate Functions

* Max
* Min
* Avg
* Sum
* Count

```sql
SELECT MAX(avail_balance) max_balance,
    MIN(avail_balance) min_balance,
    AVG(avail_balance) avg_balance,
    SUM(avail_balance) tot_balance,
    COUNT(*) num_acounts
FROM account
WHERE product_cd = 'CHK';
```

## Implicit vs Explicit Groups

When there's no `GROUP BY` clause, such as the previous example, there is an _implicit_ group (all rows returned by the query).

In most cases, however, you will want to retrieve additional coluns along with the columns generated by aggregate functons.

You'll need to add a `GROUP BY` clause to specify over which group of rows the aggregate functions should be applied:

```sql
SELECT product_cd
MAX(avail_balance) max_balance,
COUNT(*) num_accts
FROM account
GROUP BY product_cd;
```

## Counting Disctinct Values

```sql
SELECT COUNT(DISTINCT open_emp_id)
FROM account;
```

## Using Expressions

Along with using columns as arguments to aggregate functions, you can build expresions to use as arguments.

```sql
SELECT MAX(pending_balance - avail_balance) max_uncleared
FROM account;
```

## Handling `null`

All aggregate functions return the same values, ignoring any `null` values encountered.

The `count(*)` function returns all rows, even if they include `null` or not, while `count(val)` ignores `null` values encountered.

## Generating Groups

People engages in data analysis to manipulate the raw data to better suite their needs:
* Generating __totals__ for a geographic region, such as total European sales.
* Finding __outliers__, such as the top salesperson for 2005.
* Determining __frequencies__, such as the number of new acounts opened for each branch.

To answer these types of queries, you will need to ask the database server to group rouws together by one or more columns or expressions.

### Single-Column Grouping

Following query generates six groups, one for each product, and then sums the available balances for each member of the group.
```sql
SELECT product_cd, SUM(avail_balance) prod_balance
FROM account
GROUP BY product_cd;
```

### Multi-Column Grouping

Imagine you want to find total balances for both products and branches (e.g, what's the total balance for all checking accounts opened at the Woburn branch?):
```sql
SELECT product_cd, open_branch_id,
    SUM(avail_balance) tot_balance
FROM account
GROUP BY product_cd, open_branch_id;
```

This quey generates 14 groups, one for each combination of product and branch found in the `account` table.

### Grouping via Expressions

You can build groups based on the values generated by expressions.

```sql
SELECT EXTRACT(YEAR FROM start_date) year,
COUNT(*) how_many
FROM employee
GROUP BY EXTRACT(YEAR FROM start_date)
```

### Generating Rollups

Let's say, that along with the total balances for each product/branch combination, you also want total balances for each distinct product.
```sql
SELECT product_cd, open_branch_id,
SUM(avail_balance) tot_balance
FROM account
GROUP BY product_cd, open_branch_id WITH ROLLUP;
```
Now, there's seven additional rows in the result set, one for each of the six distinct produts, and one for the grand total (all products combined).

If, along with totals by products, you also want to calculate totals per branch, then you can use the `with cube` option, which generates summary rows for `all` possible combinatons of the grouping columns.
```sql
SELECT product_cd, open_branch_id,
SUM (avail_balance) tot_balance
FROM account
GROUP BY product_cd, open_branch_id WITH CUBE;
```
This generates more rows, one for each of the four branch IDs.

This is an extend topic, feel free to check [MySQL documentation and get more deeper!](https://dev.mysql.com/doc/refman/8.0/en/group-by-modifiers.html)

### Group Filter Conditions

When grouping data, you can apply filter conditions to the data _after_ the groups have been generated too.

```sql
SELECT product_cd, SUM(avail_balance) prod_balance
FROM account
WHERE status = 'ACTIVE'
GROUP BY product_cd
HAVING SUM(avail_balance) >= 10000;
```

This query has two filter conditions, in the `where` clause it filters out inactive accounts, and the other in `having` clause, filtering any product whose total available balance is less than $10,000.

Thus, `where` filters __acts on data before it is grouped__, and `having` filters __acts on data after the groups have been created__.

You can include aggregate functions in the `having` clause that do not appear in the `select` clase:
```sql
SELECT product_cd, SUM(avail_balance) prod_balance
FROM account
WHERE status = 'ACTIVE'
GROUP BY product_cd
HAVING MIN(avail_balance) >= 1000
AND MAX(avail_balance) <= 10000;
```